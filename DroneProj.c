//This code is a frankenstien slap-together of the compdcm_mpu9150.c
//example code provided for the SensorHub boosterpack, some previous assignments, and some other things
//all edits to the original code made by Henry Mattoon
// used on TM4C123GH6PM

//in project options under C/C++ -> Define put "rvmdk PART_TM4C123GH6PM TARGET_IS_TM4C123_RB1 UART_BUFFERED"
//also change build path to "..;..\..\..\.."

/////////
//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "DroneProj.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"//vvv added by user vvv
#include "inc/tm4c123gh6pm.h"
#include "driverlib/uart.h"
#include <stdio.h>
#include "sensorlib/hw_mpu9150.h"
#include "sensorlib/hw_ak8975.h"
#include "sensorlib/i2cm_drv.h"
#include "sensorlib/ak8975.h"
#include "sensorlib/mpu9150.h"
#include "sensorlib/comp_dcm.h"
#include "utils/uartstdio.h"
#include "driverlib/pwm.h"



//*****************************************************************************
//GLOBALS
#define MPU9150_I2C_ADDRESS     0x68
#define PRINT_SKIP_COUNT        10

// Global instance structure for the I2C master driver.
tI2CMInstance g_sI2CInst;  
tMPU9150 g_sMPU9150Inst;
tCompDCM g_sCompDCMInst;
uint32_t g_ui32PrintSkipCounter;
volatile uint_fast8_t g_vui8I2CDoneFlag;
volatile uint_fast8_t g_vui8ErrorFlag;
volatile unsigned long speed = 30;  //originally 300. 30 means motors I used are not running at start
volatile unsigned long tilt = 0;


//**** init functions ********
//
void i2c_Init(void){ 
    //
    // Enable Peripheral Clocks 
    //	  
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C3);
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		//
    // Enable pin PD0 for I2C3 I2C3SCL
    //
    MAP_GPIOPinConfigure(GPIO_PD0_I2C3SCL);
    MAP_GPIOPinTypeI2CSCL(GPIO_PORTD_BASE, GPIO_PIN_0);

    //
    // Enable pin PD1 for I2C3 I2C3SDA
    //
    MAP_GPIOPinConfigure(GPIO_PD1_I2C3SDA);
    MAP_GPIOPinTypeI2C(GPIO_PORTD_BASE, GPIO_PIN_1);
}


void PwmInit(void){
		//
    // Enable Peripheral Clock 
    //
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);
		SysCtlPWMClockSet(SYSCTL_PWMDIV_1);
	
		//
    //First open the lock and select the bits we want to modify in the GPIO commit register.
    //
		
		HWREG(GPIO_PORTE_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
		HWREG(GPIO_PORTE_BASE + GPIO_O_CR) |= 0x01;
		
		//
    // Enable pin PE4 & PE5 for M1PWM
    //
	
    MAP_GPIOPinConfigure(GPIO_PE5_M1PWM3);
    MAP_GPIOPinConfigure(GPIO_PE4_M1PWM2);
		
		MAP_GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_5);
    MAP_GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_4);
	
		PWMGenConfigure(PWM1_BASE, PWM_GEN_1, PWM_GEN_MODE_DOWN |
			PWM_GEN_MODE_NO_SYNC); //gen2 is for pins 4&5, gen1 is for 2&3...
		
		
		//Setting up PWM
		PWMGenPeriodSet(PWM1_BASE, PWM_GEN_1, 400);
		
		
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_2, speed);//pe4
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_3, speed);//pe5
		
		PWMGenEnable(PWM1_BASE, PWM_GEN_1);

		PWMOutputState(PWM1_BASE, (PWM_OUT_2_BIT | PWM_OUT_3_BIT ), true);

}



void Interrupt_Init(void){
		IntEnable(INT_GPIOF);  							// enable interrupt 30 in NVIC (GPIOF)
		IntPrioritySet(INT_GPIOF, 0x02); 		// configure GPIOF interrupt priority as 0
		GPIO_PORTF_IM_R |= 0x11;   		// arm interrupt on PF0 and PF4
		GPIO_PORTF_IS_R &= ~0x11;     // PF0 and PF4 are edge-sensitive
		GPIO_PORTF_IBE_R &= ~0x11;   	// PF0 and PF4 not both edges trigger 
		GPIO_PORTF_IEV_R &= ~0x11;  	// PF0 and PF4 falling edge event
		
}

void PortFunctionInit(void){
    //
    // Enable Peripheral Clocks 
    //
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    //
    // Enable pin PB2 for GPIOInput
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTB_BASE, GPIO_PIN_2);
		//
    // Configure and Enable the GPIO interrupt. Used for INT signal from the
    // MPU9150
    //
		GPIOIntEnable(GPIO_PORTB_BASE, GPIO_PIN_2);
    MAP_GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_2, GPIO_FALLING_EDGE);
    MAP_IntEnable(INT_GPIOB);
	
	
	
		//
    //First open the lock and select the bits we want to modify in the GPIO commit register.
		//
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0x1;
		//
	  // Enable pin PF4 & PF0 for GPIOInput
		//
		MAP_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_0);
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);
		
		
		
    //
    //Now modify the configuration of the pins that we unlocked.
    //
		GPIO_PORTF_PUR_R |=0x11;	
}

void uart_Init(void){ 
    // Enable Peripheral Clocks 
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	  MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    // Enable pin PA0 for UART0 U0RX
    MAP_GPIOPinConfigure(GPIO_PA0_U0RX);
    MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0);
    // Enable pin PA1 for UART0 U0TX
    MAP_GPIOPinConfigure(GPIO_PA1_U0TX);
    MAP_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_1);
    // Use the internal 16MHz oscillator as the UART clock source.
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
    // Initialize the UART for console I/O.
    UARTStdioConfig(0, 115200, 16000000);
}
//
//**********MPU9150 functions*************
//
void MPU9150AppCallback(void *pvCallbackData, uint_fast8_t ui8Status){
    // If the transaction succeeded set the data flag to indicate to
    // application that this transaction is complete and data may be ready.
    if(ui8Status == I2CM_STATUS_SUCCESS)
    {
        g_vui8I2CDoneFlag = 1;
    }
    // Store the most recent status in case it was an error condition
    g_vui8ErrorFlag = ui8Status;
}

void MPU9150AppErrorHandler(char *pcFilename, uint_fast32_t ui32Line){
    //print error status and locations
    UARTprintf("\033[31;1m");
    UARTprintf("Error: %d, File: %s, Line: %d\n"
               "See I2C status definitions in sensorlib\\i2cm_drv.h\n",
               g_vui8ErrorFlag, pcFilename, ui32Line);
    // wait for fix
    while(1)
    {
        // Do Nothing
    }
}



void MPU9150AppI2CWait(char *pcFilename, uint_fast32_t ui32Line){
    // Put the processor to sleep while we wait for the I2C driver to
    // indicate that the transaction is complete.
    while((g_vui8I2CDoneFlag == 0) && (g_vui8ErrorFlag == 0))
    {
        // Do Nothing
    }
    // call error handler if problem
    if(g_vui8ErrorFlag)
    {
        MPU9150AppErrorHandler(pcFilename, ui32Line);
    }
    // clear the data flag for next use.
    g_vui8I2CDoneFlag = 0;
}
//
//**********interupt Handlers ************
//
void GPIOPortF_Handler(void){

	IntDisable(INT_GPIOF);
	SysCtlDelay(53333);	// Delay for a while
	IntEnable(INT_GPIOF);
	//UARTprintf("\033[24;68H", "yo");//testing purposes
	//SW1 is pressed
	if(GPIO_PORTF_RIS_R&0x10)
	{
		// acknowledge flag for PF4
		GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_4); 
		//UARTprintf("\033[24;68H", "yo");
		speed=speed+10;
		if(speed>400){
			speed=400;
		}
		//setting  base speed of both sides
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_3, speed);
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_2, speed);	
	}
	
	//SW2 is pressed
  if(GPIO_PORTF_RIS_R&0x01)
	{
		// acknowledge flag for PF0
		GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_0);
		//UARTprintf("\033[24;68H", "hi");
		speed=speed-10;
		if(speed<10){
			speed=10;
		}
		//setting  base speed of both sides
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_3, speed);
		PWMPulseWidthSet(PWM1_BASE, PWM_OUT_2, speed);
	}

}



void MPU9150I2CIntHandler(void){
    // Pass through to the I2CM interrupt handler provided by sensor library.
    // This is required to be at application level so that I2CMIntHandler can
    // receive the instance structure pointer as an argument.
    I2CMIntHandler(&g_sI2CInst);
}

void GPIOPortB_Handler(void) {
    unsigned long ulStatus;
    ulStatus = GPIOIntStatus(GPIO_PORTB_BASE, true);
    // Clear all the pin interrupts that are set
    GPIOIntClear(GPIO_PORTB_BASE, ulStatus);
    if(ulStatus & GPIO_PIN_2)
    {
        // MPU9150 Data is ready for retrieval and processing.
        MPU9150DataRead(&g_sMPU9150Inst, MPU9150AppCallback, &g_sMPU9150Inst);
    }
}

//
//********Main Function***********
//
int main(void){
	
	int_fast32_t i32IPart[16], i32FPart[16];
  uint_fast32_t ui32Idx, ui32CompDCMStarted;
  float pfData[16];
  float *pfAccel, *pfGyro, *pfMag, *pfEulers, *pfQuaternion;
	int speedLeft=0;
	int speedRight=0;

	pfAccel = pfData;
  pfGyro = pfData + 3;
  pfMag = pfData + 6;
  pfEulers = pfData + 9;
  pfQuaternion = pfData + 12;

	PortFunctionInit();
	PwmInit();
	i2c_Init();
	Interrupt_Init();
	uart_Init();
	IntMasterEnable();
	//
	// Keep only some parts of the systems running while in sleep mode.
	// GPIOB is for the MPU9150 interrupt pin.
	// UART0 is the virtual serial port
	// I2C3 is the I2C interface to the ISL29023
	// GPIOF is for the buttons
	// PWM1 is for the PWM control used for the motors
	//
	SysCtlPeripheralClockGating(true);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_GPIOB);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_UART0);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_I2C3);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_GPIOF);
	SysCtlPeripheralSleepEnable(SYSCTL_PERIPH_PWM1);

	I2CMInit(&g_sI2CInst, I2C3_BASE, INT_I2C3, 0xff, 0xff,
             MAP_SysCtlClockGet());
	MPU9150Init(&g_sMPU9150Inst, &g_sI2CInst, MPU9150_I2C_ADDRESS,
                MPU9150AppCallback, &g_sMPU9150Inst);
	
	MPU9150AppI2CWait(__FILE__, __LINE__);
	
		//
    // Write application specifice sensor configuration such as filter settings
    // and sensor range settings.
    //
    g_sMPU9150Inst.pui8Data[0] = MPU9150_CONFIG_DLPF_CFG_94_98;
    g_sMPU9150Inst.pui8Data[1] = MPU9150_GYRO_CONFIG_FS_SEL_250;
    g_sMPU9150Inst.pui8Data[2] = (MPU9150_ACCEL_CONFIG_ACCEL_HPF_5HZ |
                                  MPU9150_ACCEL_CONFIG_AFS_SEL_2G);
    MPU9150Write(&g_sMPU9150Inst, MPU9150_O_CONFIG, g_sMPU9150Inst.pui8Data, 3,
                 MPU9150AppCallback, &g_sMPU9150Inst);

    //
    // Wait for transaction to complete
    //
    MPU9150AppI2CWait(__FILE__, __LINE__);

    //
    // Configure the data ready interrupt pin output of the MPU9150.
    //
    g_sMPU9150Inst.pui8Data[0] = MPU9150_INT_PIN_CFG_INT_LEVEL |
                                    MPU9150_INT_PIN_CFG_INT_RD_CLEAR |
                                    MPU9150_INT_PIN_CFG_LATCH_INT_EN;
    g_sMPU9150Inst.pui8Data[1] = MPU9150_INT_ENABLE_DATA_RDY_EN;
    MPU9150Write(&g_sMPU9150Inst, MPU9150_O_INT_PIN_CFG,
                 g_sMPU9150Inst.pui8Data, 2, MPU9150AppCallback,
                 &g_sMPU9150Inst);

    //
    // Wait for transaction to complete
    //
    MPU9150AppI2CWait(__FILE__, __LINE__);
		CompDCMInit(&g_sCompDCMInst, 1.0f / 50.0f, 0.2f, 0.6f, 0.2f);


		//Setting up frame to put data displayed with UART, For debugging perposes 
		UARTprintf("\033[2J\033[H");
    UARTprintf("Sensor Hub Data and \"Speed\"\n\n");
    UARTprintf("\033[20GX\033[31G|\033[43GY\033[54G|\033[66GZ\n\n");
    UARTprintf("Accel\033[8G|\033[31G|\033[54G|\n\n");
    UARTprintf("Gyro\033[8G|\033[31G|\033[54G|\n\n");
    UARTprintf("Mag\033[8G|\033[31G|\033[54G|\n\n");
    UARTprintf("\n\033[20GRoll\033[31G|\033[43GPitch\033[54G|\033[66GYaw\n\n");
    UARTprintf("Eulers\033[8G|\033[31G|\033[54G|\n\n");
    UARTprintf("\n\033[17GQ1\033[26G|\033[35GQ2\033[44G|\033[53GQ3\033[62G|\033[71GQ4\n\n");
    UARTprintf("Q\033[8G|\033[26G|\033[44G|\033[62G|\n\n");
		UARTprintf("Speed\033[8G|\033[26G|\033[44G|\033[62G|\n\n");

		while(1)//loop forever
    {
			
        while(!g_vui8I2CDoneFlag) // Go to sleep mode while waiting for data ready.
        {
            SysCtlSleep();
        }

        g_vui8I2CDoneFlag = 0; // Clear the flag

        MPU9150DataAccelGetFloat(&g_sMPU9150Inst, pfAccel, pfAccel + 1, pfAccel + 2); // Get floating point version of the Accel Data in m/s^2.

        MPU9150DataGyroGetFloat(&g_sMPU9150Inst, pfGyro, pfGyro + 1, pfGyro + 2);  // Get floating point version of angular velocities in rad/sec

        MPU9150DataMagnetoGetFloat(&g_sMPU9150Inst, pfMag, pfMag + 1, pfMag + 2); // Get floating point version of magnetic fields strength in tesla (MIGHT NOT NEED THIS ONE)

        if(ui32CompDCMStarted == 0) // Check if this is our first data ever.
        {

            ui32CompDCMStarted = 1; // Set flag indicating that DCM is started.
						// Perform the seeding of the DCM with the first data set.
            CompDCMMagnetoUpdate(&g_sCompDCMInst, pfMag[0], pfMag[1], pfMag[2]);
            CompDCMAccelUpdate(&g_sCompDCMInst, pfAccel[0], pfAccel[1], pfAccel[2]);
            CompDCMGyroUpdate(&g_sCompDCMInst, pfGyro[0], pfGyro[1], pfGyro[2]);
            CompDCMStart(&g_sCompDCMInst);
        }
        else
        {
            // DCM Is already started.  Perform the incremental update.
            CompDCMMagnetoUpdate(&g_sCompDCMInst, pfMag[0], pfMag[1], pfMag[2]);
            CompDCMAccelUpdate(&g_sCompDCMInst, pfAccel[0], pfAccel[1], pfAccel[2]);
            CompDCMGyroUpdate(&g_sCompDCMInst, -pfGyro[0], -pfGyro[1], -pfGyro[2]);
            CompDCMUpdate(&g_sCompDCMInst);
        }

        // Increment the skip counter.  Skip counter is used so we do not
        // overflow the UART with data.
        g_ui32PrintSkipCounter++;
        if(g_ui32PrintSkipCounter >= PRINT_SKIP_COUNT)
        {
            
            g_ui32PrintSkipCounter = 0; // Reset skip counter.

            
            CompDCMComputeEulers(&g_sCompDCMInst, pfEulers, pfEulers + 1, pfEulers + 2); // Get Euler data. (Roll Pitch Yaw)

            CompDCMComputeQuaternion(&g_sCompDCMInst, pfQuaternion); // Get Quaternions.

            // convert mag data to micro-tesla for better human interpretation.
            pfMag[0] *= 1e6;
            pfMag[1] *= 1e6;
            pfMag[2] *= 1e6;

            // Convert Eulers to degrees. 180/PI = 57.29...
            
            pfEulers[0] *= 57.295779513082320876798154814105f;
            pfEulers[1] *= 57.295779513082320876798154814105f;
            pfEulers[2] *= 57.295779513082320876798154814105f;
            if(pfEulers[2] < 0) // Convert Yaw to 0 to 360 to approximate compass headings.
            {
                pfEulers[2] += 360.0f;
            }

            // Now drop back to using the data as a single array for the
            // purpose of decomposing the float into a integer part and a
            // fraction (decimal) part.
            for(ui32Idx = 0; ui32Idx < 16; ui32Idx++)
            {
                //
                // Conver float value to a integer truncating the decimal part.
                //
                i32IPart[ui32Idx] = (int32_t) pfData[ui32Idx];						//data comes from pfData

                //
                // Multiply by 1000 to preserve first three decimal values.
                // Truncates at the 3rd decimal place.
                //
                i32FPart[ui32Idx] = (int32_t) (pfData[ui32Idx] * 1000.0f); //data comes from pfData

                //
                // Subtract off the integer part from this newly formed decimal
                // part.
                //
                i32FPart[ui32Idx] = i32FPart[ui32Idx] -
                                    (i32IPart[ui32Idx] * 1000);

                //
                // make the decimal part a positive number for display.
                //
                if(i32FPart[ui32Idx] < 0)
                {
                    i32FPart[ui32Idx] *= -1;
                }
            }
						
						
						//Because of time constraints I wasn't to do anything beyond showing that
						//the motors' speeds changed based on how far the sensor hub is turned
						//Also with additional time this would have been moved to a periodic interrupt
						speedLeft=speed-i32IPart[10];
						speedRight=speed+i32IPart[10];
						if(speedLeft<10){
							speedLeft=10;
						}else if(speedLeft>400){
							speedLeft=400;
						}
						if(speedRight<10){
							speedRight=10;
						}else if(speedRight>400){
							speedRight=400;
						}
						PWMPulseWidthSet(PWM1_BASE, PWM_OUT_3, speedRight);
						PWMPulseWidthSet(PWM1_BASE, PWM_OUT_2, speedLeft);
						
						
						
						//  UART Debugging taken from sensor hub example code
            // Print the acceleration numbers in the table.
            //															 integer   &  fraction part
            UARTprintf("\033[5;17H%3d.%03d", i32IPart[0], i32FPart[0]);//i32IPart[0],i32FPart[0]	x
            UARTprintf("\033[5;40H%3d.%03d", i32IPart[1], i32FPart[1]);//i32IPart[1], i32FPart[1]	y
            UARTprintf("\033[5;63H%3d.%03d", i32IPart[2], i32FPart[2]);//i32IPart[2], i32FPart[2]	z

            // Print the angular velocities in the table.
            UARTprintf("\033[7;17H%3d.%03d", i32IPart[3], i32FPart[3]);
            UARTprintf("\033[7;40H%3d.%03d", i32IPart[4], i32FPart[4]);
            UARTprintf("\033[7;63H%3d.%03d", i32IPart[5], i32FPart[5]);
            //
            // Print the magnetic data in the table.
            UARTprintf("\033[9;17H%3d.%03d", i32IPart[6], i32FPart[6]);
            UARTprintf("\033[9;40H%3d.%03d", i32IPart[7], i32FPart[7]);
            UARTprintf("\033[9;63H%3d.%03d", i32IPart[8], i32FPart[8]);
            //
            // Print the Eulers in a table.
            UARTprintf("\033[14;17H%3d.%03d", i32IPart[9], i32FPart[9]); //roll
            UARTprintf("\033[14;40H%3d.%03d", i32IPart[10], i32FPart[10]); //pitch
            UARTprintf("\033[14;63H%3d.%03d", i32IPart[11], i32FPart[11]); //yaw
            //
            // Print the quaternions in a table format.
            UARTprintf("\033[19;14H%3d.%03d", i32IPart[12], i32FPart[12]);	//q1
            UARTprintf("\033[19;32H%3d.%03d", i32IPart[13], i32FPart[13]);	//q2
            UARTprintf("\033[19;50H%3d.%03d", i32IPart[14], i32FPart[14]);	//q3
            UARTprintf("\033[19;68H%3d.%03d", i32IPart[15], i32FPart[15]);	//q4
						
						
						//"speeds" of boths sides
						UARTprintf("\033[21;14H%3d", speedLeft);
						UARTprintf("\033[21;32H%3d", speed);	//q2
            UARTprintf("\033[21;50H%3d", speedRight);
						UARTprintf("\033[21;68H%3d", i32IPart[10]);
						
        }
    }
}


